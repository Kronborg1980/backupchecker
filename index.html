// --- Core Logic ---
async function checkShopAccess() {
  const emailInputs = document.querySelectorAll('.email-input');
  const currentEmails = Array.from(emailInputs)
    .filter(input => input.hasAttribute('readonly'))
    .map(input => input.value.trim());

  // Use multiple approaches to check for queue
  const targetUrl = 'https://www.pokemoncenter.com';
  
  try {
    // Approach 1: Direct fetch with minimal headers
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 10000);
    
    let response, text, finalUrl;
    
    // Try a HEAD request first (less likely to trigger blocks)
    try {
      response = await fetch(targetUrl, {
        method: 'HEAD',
        mode: 'no-cors',
        headers: {
          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
          'Accept-Language': 'en-US,en;q=0.9',
          'Cache-Control': 'no-cache',
          'Pragma': 'no-cache'
        },
        credentials: 'omit',
        referrerPolicy: 'no-referrer',
        signal: controller.signal
      });
    } catch (headError) {
      console.log('HEAD request failed, trying GET');
    }
    
    clearTimeout(timeoutId);
    
    // Approach 2: Try to get page via fetch with different proxy
    const fetchOptions = {
      method: 'GET',
      headers: {
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
        'Accept-Language': 'en-US,en;q=0.9',
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        'Sec-Fetch-Dest': 'document',
        'Sec-Fetch-Mode': 'navigate',
        'Sec-Fetch-Site': 'none',
        'Sec-Fetch-User': '?1',
        'Upgrade-Insecure-Requests': '1'
      },
      mode: 'cors',
      credentials: 'omit',
      referrerPolicy: 'no-referrer',
      signal: controller.signal
    };
    
    // Try multiple proxy endpoints
    const proxyEndpoints = [
      `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`,
      `https://api.allorigins.win/get?url=${encodeURIComponent(targetUrl)}&callback=?`,
      `https://thingproxy.freeboard.io/fetch/${encodeURIComponent(targetUrl)}`,
      `https://cors-anywhere.herokuapp.com/${targetUrl}`
    ];
    
    for (const proxy of proxyEndpoints) {
      try {
        const proxyController = new AbortController();
        const proxyTimeout = setTimeout(() => proxyController.abort(), 8000);
        
        const proxyResponse = await fetch(proxy, {
          ...fetchOptions,
          signal: proxyController.signal
        });
        
        clearTimeout(proxyTimeout);
        
        if (proxyResponse.ok) {
          // Handle AllOrigins format
          if (proxy.includes('allorigins.win')) {
            const data = await proxyResponse.json();
            text = data.contents;
          } else {
            text = await proxyResponse.text();
          }
          finalUrl = proxyResponse.url;
          break;
        }
      } catch (proxyError) {
        console.log(`Proxy ${proxy} failed, trying next`);
        continue;
      }
    }
    
    const now = new Date().toLocaleTimeString();
    lastChecked.textContent = now;
    
    if (!text) {
      // If all proxies fail, try a simple fetch from a different domain
      // that might have the queue status
      try {
        const fallbackResponse = await fetch('https://status.pokemon.com', fetchOptions);
        if (fallbackResponse.ok) {
          text = await fallbackResponse.text();
          finalUrl = fallbackResponse.url;
        }
      } catch (fallbackError) {
        // Last resort: Check if we can even resolve the domain
        try {
          // This won't give us content but tells us if DNS resolves
          await fetch(`https://dns.google/resolve?name=pokemoncenter.com&type=A`);
          statusText.textContent = 'DNS Resolves';
          statusText.className = 'font-semibold status-neon-yellow';
          statusDetails.textContent = 'Site exists but cannot fetch content. Likely blocked.';
          return;
        } catch (dnsError) {
          statusText.textContent = 'Network Error';
          statusText.className = 'font-semibold status-neon-red';
          statusDetails.textContent = 'Cannot reach Pokemon Center. Check internet connection.';
          return;
        }
      }
    }
    
    // ENHANCED QUEUE DETECTION LOGIC
    let isQueue = false;
    let queuePosition = null;
    let shopAccessible = false;
    let isBlocked = false;
    
    if (text) {
      // Check for queue patterns (case insensitive, various formats)
      const queuePatterns = [
        /queue-it[\s\S]*?waiting[\s\S]*?room/i,
        /you[\s\S]*?are[\s\S]*?in[\s\S]*?line/i,
        /waiting[\s\S]*?room/i,
        /estimated[\s\S]*?wait/i,
        /users[\s\S]*?ahead/i,
        /queue[\s\S]*?position/i,
        /queue-id/i,
        /\/queue\//i,
        /queue\.js/i,
        /queue-it\.com/i
      ];
      
      const blockedPatterns = [
        /access[\s\S]*?denied/i,
        /just[\s\S]*?moment/i,
        /cloudflare/i,
        /captcha/i,
        /challenge/i,
        /distil/i,
        /incapsula/i,
        /blocked/i,
        /forbidden/i
      ];
      
      const shopPatterns = [
        /pok√©mon[\s\S]*?center/i,
        /sign[\s\S]*?in/i,
        /my[\s\S]*?cart/i,
        /shop[\s\S]*?now/i,
        /add[\s\S]*?to[\s\S]*?cart/i,
        /product[\s\S]*?grid/i,
        /trading[\s\S]*?card[\s\S]*?game/i,
        /plush/i,
        /figures/i,
        /apparel/i
      ];
      
      // Check for queue first
      for (const pattern of queuePatterns) {
        if (pattern.test(text)) {
          isQueue = true;
          
          // Extract queue position
          const positionMatch = text.match(/(\d+,?\d*)\s*(users? ahead|people ahead|ahead of you|in line)/i) ||
                               text.match(/position\s*[#:]?\s*(\d+,?\d*)/i) ||
                               text.match(/waiting:\s*(\d+,?\d*)/i);
          
          if (positionMatch) {
            queuePosition = positionMatch[1];
          }
          break;
        }
      }
      
      // Check if blocked
      for (const pattern of blockedPatterns) {
        if (pattern.test(text)) {
          isBlocked = true;
          break;
        }
      }
      
      // Check if shop is accessible
      if (!isQueue && !isBlocked) {
        for (const pattern of shopPatterns) {
          if (pattern.test(text)) {
            shopAccessible = true;
            break;
          }
        }
      }
      
      // Additional checks based on response characteristics
      const isSmallResponse = text.length < 5000;
      const hasQueueScript = text.includes('queue') && (text.includes('script') || text.includes('function'));
      
      if (!isQueue && hasQueueScript) {
        isQueue = true;
      }
      
      // Determine final status
      if (isQueue) {
        handleAlert("Queue Detected!", 
          queuePosition ? `In queue. Position: ${queuePosition}` : "Waiting in queue.", 
          currentEmails);
      } 
      else if (isBlocked) {
        handleAlert("Bot Blocked", "PokemonCenter is blocking access (likely Cloudflare/anti-bot).", currentEmails);
      }
      else if (shopAccessible) {
        handleAlert("Shop Accessible!", "Pokemon Center shop content detected.", currentEmails);
      }
      else if (isSmallResponse) {
        statusText.textContent = "Limited Response";
        statusText.className = 'font-semibold status-neon-yellow';
        statusDetails.textContent = `Response is small (${text.length} chars). May be challenge page.`;
      }
      else {
        // If we got content but can't determine status
        statusText.textContent = "Site Reachable";
        statusText.className = 'font-semibold text-white-glow';
        statusDetails.textContent = `Got response (${text.length} chars) but content unclear.`;
        
        // Check if it might be an error page
        if (text.includes('error') || text.includes('sorry') || text.includes('unavailable')) {
          handleAlert("Possible Outage", "Site may be experiencing issues.", currentEmails);
        }
      }
    } else {
      statusText.textContent = "No Content";
      statusText.className = 'font-semibold status-neon-yellow';
      statusDetails.textContent = "Could not retrieve page content.";
    }
    
  } catch (error) {
    console.error('Check error:', error);
    const now = new Date().toLocaleTimeString();
    lastChecked.textContent = now;
    
    if (error.name === 'AbortError') {
      statusText.textContent = 'Timeout';
      statusText.className = 'font-semibold status-neon-red';
      statusDetails.textContent = 'Request timed out. Site may be slow or blocking.';
    } else {
      statusText.textContent = 'Network Error';
      statusText.className = 'font-semibold status-neon-red';
      statusDetails.textContent = `Error: ${error.message}`;
    }
  }
}

function handleAlert(status, details, emails) {
  const prevStatus = statusText.dataset.previousStatus;
  
  // Update visual status
  statusText.textContent = status;
  statusDetails.textContent = details;
  statusText.dataset.previousStatus = status;
  
  // Styling
  if (status.includes("Accessible")) {
    statusText.className = 'font-semibold status-neon-green';
    // Don't send alerts for accessible status to avoid spam
    return;
  } else if (status.includes("Queue")) {
    statusText.className = 'font-semibold status-neon-red';
    playThreeBeeps();
  } else if (status.includes("Blocked") || status.includes("Outage")) {
    statusText.className = 'font-semibold status-neon-red';
    playThreeBeeps();
  } else {
    statusText.className = 'font-semibold text-white-glow';
  }
  
  // Send alerts only if status changed
  if (prevStatus !== status) {
    // Only send alerts for queue, blocked, or outage
    if (status.includes("Queue") || status.includes("Blocked") || status.includes("Outage")) {
      sendEmail(status, details, emails);
      sendDiscordMessage(status, details);
    }
  }
}
